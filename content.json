{"meta":{"title":"雪松の部落(lào)阁","subtitle":null,"description":"好少年光芒万丈","author":"PandaQ","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2019-08-21T00:26:31.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[雪松の部落(lào)阁] 与&nbsp; 雪松のRobot&nbsp; （ マツのロボット ） 对话中... function bot_ui_ini() { var botui = new BotUI(\"hello-mashiro\"); botui.message.add({ delay: 800, content: \"您好, 我是小松，让我来帮您 😃\" }).then(function () { botui.action.button({ delay: 1600, action: [{ text: \"然后呢？ 😃\", value: \"sure\" }, { text: \"少废话！ 🙄\", value: \"skip\" }] }).then(function (a) { \"sure\" == a.value && sure(); \"skip\" == a.value && end() }) }); var sure = function () { botui.message.add({ delay: 600, content: \"现在连不上网，待会再试 😃\" }).then(function () { secondpart() }) }, end = function () { botui.message.add({ delay: 600, content: \"![...](https://view.moezx.cc/images/2018/05/06/a1c4cd0452528b572af37952489372b6.md.jpg)\" }) } } bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"categories","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-20T15:06:54.000Z","comments":true,"path":"categoriespage/index.html","permalink":"/categoriespage/index.html","excerpt":"","text":"","keywords":"分类"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2019-08-09T03:41:38.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-06-01T14:21:46.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-08-21T00:31:00.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"本站主题Cedar修改自Hexo主题Sakura，Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Cedar 🌲"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-06-01T14:21:46.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"Linux内核中常用的数据结构和算法之红黑树","slug":"2-4.Linux内核中常用的数据结构和算法之红黑树","date":"2019-09-05T15:54:00.000Z","updated":"2019-10-01T12:14:01.000Z","comments":true,"path":"2019/09/05/2-4.Linux内核中常用的数据结构和算法之红黑树/","link":"","permalink":"/2019/09/05/2-4.Linux内核中常用的数据结构和算法之红黑树/","excerpt":"","text":"Linux内核中常用的数据结构和算法之红黑树1. 红黑树1.1 2-3 树2-3树能够很好地实现树的平衡。 2-3树的节点种类： 2-node：一个key值，两个儿子节点； 3-node：两个key值，三个儿子节点； 1.2 2-3树的插入向2-3树的节点插入一个新节点由以下几种操作： 1.向2节点插入一个新节点，直接将新节点并为3节点（排序）； 2.向3节点插入一个新节点，临时变为4节点（排序），然后分裂（4节点分裂出的中间值，并入父节点，递归执行12步）； 1.3 2-3树插入操作时间复杂度普通二叉树的查找时间复杂度为[O($log_2n$), O($n$)]之间。2-3树和红黑树作为平衡二叉树的一种，查找和插入（忽略调整）的时间复杂度为O($log_2n$)。 详见以下链接：二叉树2-3-4树红黑树Red-Black Trees算法可视化红黑树的可视化 1.4 由2-3树到红黑树及红黑树的条件如图将2-3树的所有3节点，左边的值作为红节点，其他作为黑节点，则形成一种与2-3树一一对应的红黑树（左倾2-3树） 形成的树符合以下条件： 1.每个节点要么是红色，要么是黑色（2-3树节点要么是2节点要么是3节点） 2.根节点必须是黑色 3.红色节点不能连续（红色节点的子和父不能为红）（不能有4节点。注意2-3的4节点是临时的） 4.对于每个节点，从该点至null（树的尾端）的任何路径，都含有相同个数的黑色节点。 1.5 红黑树的插入操作 1.查找新节点的插入位置，并入2节点或3节点（会形成临时4节点） 2.对节点内排序，整理节点颜色 3.若新节点是临时4节点，则将中间值取出，并入父节点，递归操作 1.6 红黑树的应用 1.java8中，HashMap的实现中，如果发现链表长度超过 8，那么将链表转储成红黑树。 2.java中，TreeMap的存储方式是红黑树。（HashMap无序，TreeMap有序，都是非线程安全） 3.Linux内核中大量使用红黑树，如虚拟地址空间VMA的管理。 2. 在Linux内核中使用红黑树红黑树广泛应用于内核的内存管理和进程调度中，用于将排序的元素组织到树中。内核中使用红黑树，需要包含linux/rbtree.h。在内核代码的documentation/Rbtree.txt中有一个使用红黑树的一个例子。 2.1 数据结构定义struct mytype{ struct rb_node node; //用于实现红黑树的各种功能 int key; //需要自己定义key和排序方式，体现在查找和插入操作中 //可能还需要自定义的要存储的数据结构value } 2.2 根节点的定义struct rb_root mytree = RB_ROOT; 2.3 根据Key查找 1.获得根节点： struct rb_node *node = root-&gt;rb_node; 以下是循环查找while(node)的过程： 2.通过node = node-&gt;rb_left和node = node-&gt;rb_right在节点中移动 3.通过struct mytype *data = container_of(node,struct mytype,node);取出mytype类型的数据 4.比较mytype的key值左移右移 循环结束后，未找到返回NULL。 2.4 插入一个元素到红黑树中 1.获得根节点的指针（涉及到修改，所以是两层指针） struct rb_node **new = &amp;(root-&gt;rb_node); 2.定义一个指针用于保存插入节点的父节点（待实验验证） struct rb_node *parent = NULL; 3.查找要插入的位置 注意while(*new) 4.rb_link_node(&amp;data-&gt;node, parent, new) rb_link_node(&amp;data-&gt;node,parent,new);//data是mytype类型的数据；new是查找到的位置 5.rb_insert_color(&amp;data-&gt;node, root) rb_insert_color(&amp;data-&gt;node, root);//data是mytype类型的数据；root是rb_root类型的根 在Linux内核中使用红黑树原文见《奔跑吧Linux内核》Page34。","categories":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"《奔跑吧Linux内核入门篇》","slug":"《奔跑吧Linux内核入门篇》","permalink":"/tags/《奔跑吧Linux内核入门篇》/"}],"keywords":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}]},{"title":"Linux内核中常用的数据结构和算法之链表","slug":"2-3.Linux内核中常用的数据结构和算法之链表","date":"2019-09-04T13:42:00.000Z","updated":"2019-09-04T15:03:23.000Z","comments":true,"path":"2019/09/04/2-3.Linux内核中常用的数据结构和算法之链表/","link":"","permalink":"/2019/09/04/2-3.Linux内核中常用的数据结构和算法之链表/","excerpt":"","text":"Linux内核中常用的数据结构和算法之链表1. 链表1.1 单向链表单向链表具有单向移动性，只能访问当前节点的后继节点，实际项目中运用得较少。数据结构如下： struct list{ int data; //有效数据 struct list *next;//指向下一元素的指针 }; 1.2 双向链表双向链表的指针区包含两个指针：前驱指针和后继指针。数据结构如下： struct list{ int data; //有效数据 struct list *next;//后继指针 struct list *prev;//前驱指针 }; 2. Linux 内核链表实现2.1 定义Linux内核实现了一套纯链表的封装，链表节点数据结构只有指针区而没有数据区，还封装了各种操作函数，如创建节点函数、插入节点函数、删除节点函数、遍历节点函数等。Linux内核链表使用struct list_head数据结构来描述。 &lt;include/linux/types.h&gt; struct list_head{ struct list_head *next,*prev; }; 2.2 使用方法2.2.1 嵌入其他数据结构示例代码如下： &lt;include/linux/mm_types.h&gt; sturct page{ ... struct list_head lru; ... }; 2.2.2 初始化把next和prev指针都初始化并指向自己，这样便初始化了一个带头节点的空链表。（1）静态初始化 &lt;include/linux/list.h&gt; #define LIST_HEAD_INIT(name) {&amp;(name),&amp;(name)} #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name) （2）动态初始化 static inline void INIT_LIST_HEAD(struct list_head *list){ list-&gt;next = list; list-&gt;prev = list; } 2.2.3 添加节点list_add()将一个节点添加至表头，list_add_tail()将一个节点添加至表尾。 &lt;include/linux/list.h&gt; void list_add(struct list_head *new, struct list_head *head) list_add_tail(struct list_head *new, struct list_head *head) 2.2.4 遍历节点#define list_for_each(pos, head) \\ for(pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next) 上述宏遍历了一个一个节点的位置，使用list_entry()宏获取节点本身的数据结构。 #define list_entry(ptr, type, member) \\ container_of(ptr,type,member) //container_of()宏定义在kernel.h中 #define container_of(ptr,type,member) ({ \\ //将ptr转为指向member成员的指针 const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \\ //将ptr指针减去member成员的偏移个字节，即为结构体的地址 (type *)( (char *)__mptr - offsetof(type,member) );}) //offsetof宏的含义是，取地址为0的TYPE类型的结构体中MEMBER成员的地址， //即为MEMBER成员的偏移 #define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER) 下面是遍历链表的一个例子。 &lt;drivers/block/osdblk.c&gt; static ssize_t class_osdblk_list(struct class *c, struct class_attribute *attr, char *data) { int n = 0; struct list_head *tmp; list_for_each(tmp, &amp;osdblkdev_list){ struct osdblk_device *osdev; osdev = list_entry(tmp, struct osdblk_device, node); n += sprintf(data+n, &quot;%d %d %llu %s\\n&quot;, osdev-&gt;id, osdev-&gt;major, osdev-&gt;obj.partition, osdev-&gt;obj.id, osdev-&gt;osd_path); } return n; }","categories":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"《奔跑吧Linux内核入门篇》","slug":"《奔跑吧Linux内核入门篇》","permalink":"/tags/《奔跑吧Linux内核入门篇》/"}],"keywords":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}]},{"title":"Linux内核中常用的C语言技巧","slug":"2-2.Linux内核中常用的C语言技巧","date":"2019-08-29T15:12:00.000Z","updated":"2019-08-29T16:55:45.000Z","comments":true,"path":"2019/08/29/2-2.Linux内核中常用的C语言技巧/","link":"","permalink":"/2019/08/29/2-2.Linux内核中常用的C语言技巧/","excerpt":"","text":"Linux内核中常用的C语言技巧GCC 的C编译器除了支持ANSI C标准之外，还扩充了C语言，以支持代码优化、目标代码布局和安全检查。称为GNU C语言 1. 语句表达式括号里的复合语句可以看作一个表达式，称为语句表达式。语句表达式中可以使用循环、跳转和局部变量等。#define max(a,b) ((a) &gt; (b) ? (a) : (b))不安全，a，b可能会计算两次，可写成如下形式： #define maxint(a,b) \\ ({int _a = (a), _b = (b); _a &gt; _b ? _a : _b}) typeof可以用来构造新的类型。不知a，b类型，可写成： &lt;inclue/linux/kernel.h&gt; #define max(x,y) ({ \\ typeof(x) _min1 = (x); \\ typeof(y) _min2 = (y); \\ (void) (&amp;_min1 == &amp;_min2); \\ _min1 &lt; _min2 ? _min1 : _min2}) 2. 零长数组GNU C语言允许使用变长数组，在定义数据结构时很有用： struct line { int length; char contents[0]; //变长数组 }; 3. case范围 case &#39;A&#39; ... &#39;Z&#39;: case 1 ... 10: 4. 标号元素标准C要求数组或结构体的初始化值必须按照固定顺序，而GNU C可以： &lt;drivers/char/mem.c&gt; static const struct file_operations zero_fogs = { .llseek = zero_lseek, .read = new_sync_read, .write = write_zero, .read_iter = read_iter_zero, .aio_write = aio_write_zero, .mmap = mmap_zero, }; 未知的元素初始化为0或者NULL。 5. 可变参数宏在GUN C中，宏可以接受可变数目的参数，主要用作输出函数里。 &lt;include/linux/printk.h&gt; #define pr_debug(fmt, ...) \\ dynamic_pr_debug(fmt, ##__VA_ARGS__) __VA_ARGS__是编译器保留字段 6. 函数属性GNU C 允许声明函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute），以便编译器进行特定方面的优化和更仔细的代码检查。特殊属性的语法格式为__attribute__ ((attribute-list)) 6.1 format属性int libcfs_debug_msg(struct libcfs_debug_msg_data *msgdata, const char *format1, ...) __attribute__ ((format (printf, 2, 3))); format属性告诉编译器，按照prinft的参数表的格式对函数参数进行检查，2表示第二个参数format1，3表示参数“…” 6.2 noreturn属性void __attribute__ ((noreturn)) die(void);表示该函数从不返回值，让编译器消除不必要的警告信息。 6.3 const属性static inline __attribute__((const)) read_cpuid_cachetype(void){ return read_cpuid(CTR_EL0); } const属性让编译器只调用该函数一次，以后调用返回第一次调用的结果。Linux的其他函数属性定义在complier-gcc.h中。 7. 变量属性和类型属性变量属性可对变量或结构体成员进行属性设置。类型属性常见的有 alignment、packed和section等。 7.1 aligment属性aligment属性规定变量或者结构体成员的最小对齐格式，以字节为单位。 struct qib_user_info { __u32 spu_userversion; __u64 spu_base_info; }__aligment(8); 7.2 packed属性packed属性可以使变量或者结构体成员使用最小的对齐方式，对变量是以字节对齐，对域是以位对齐。 struct test{ char a; int x[2] __attribute__((packed)); };//该结构体占9字节。 8. 内建函数GNU C语言提供一系列的内建函数进行优化，这些内建函数以“builtin”作为函数前缀。 8.1 __builtin_constant_p(x)#define __swab16(x) \\ (__builtin_constant_p((__u16)(x)) ? \\ ___const_swab16(x) : __fswab16(x)) ) 判断 x是否在编译时就可以被确定为常量，若是，返回1，否则返回0。 8.2 __builtin_expect(exp,c)_builtin_expect(exp,c)意思是exp==c的概率很大，用来引导GCC编译器进行条件分支预测，提高CPU预取指令的正确率。 #define LIKELY(x) __builtin_expect(!!(x),1) //x很可能为真 #define UNLIKELY(x) __builtin_expect(!!(x),0) //x很肯为假 8.3 __builtin_prefetch(const void *addr, int rw, int locality)主动进行数据预取，在使用地址addr的值之前就将其加载到cache中，减少读取的延迟，从而提高性能。 addr 表示预取数据的地址； rw 表示读写属性，1表示可写，0表示只读； locality表示数据在cache中的时间局部性，0表示读取完值后不用保留在cache中，1-3表示时间局部性逐渐增强。下面是prefetch进行优化的一个例子。 9. asmlinkage&lt;arch/x86/include/asm/linkage.h&gt; #define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) __attribute__((regparm(0)))告诉编译器，该函数不需要通过任何寄存器来传递参数。 标准C中，x86结构，函数形参传入的参数和局部变量一起分配到函数的堆栈中； ARM 函数参数通过寄存器传递参数（ATPCS标准），ARM中的R0～R4寄存器存放传入参数，参数超过5个，多余参数存在局部堆栈中。ARM平台没有定义asmlinkage。 10. UL数字常量被隐形定义为int类型，两个int类型相加可能会溢出，通过UL强制将int类型的数据转换为unsigned long 类型，如15UL。","categories":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"《奔跑吧Linux内核入门篇》","slug":"《奔跑吧Linux内核入门篇》","permalink":"/tags/《奔跑吧Linux内核入门篇》/"}],"keywords":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}]},{"title":"Linux常用的编译工具","slug":"2-1.Linux内核基础知识1","date":"2019-08-29T14:30:00.000Z","updated":"2019-08-29T16:45:05.000Z","comments":true,"path":"2019/08/29/2-1.Linux内核基础知识1/","link":"","permalink":"/2019/08/29/2-1.Linux内核基础知识1/","excerpt":"","text":"Linux常用的编译工具1. GCC 工具GCC 的编译流程：预处理、编译、汇编、链接。 预处理 Pre-Process： 预处理器 将C代码通过预处理器将头文件，宏进行展开生成.i文件 编译 Complie：通过C语言的编译器ccl生成汇编程序.s文件 汇编 Assemble：通过汇编器AS生成可重定位的目标程序.o文件 链接 Link：通过链接器将所有文件和C语言库文件链接成可执行程序 2. ARM GCC2.1 本地编译在当前目标平台编译出来的程序，并且可以运行在当前平台上。 2.2 交叉编译在一种平台上编译，然后放在另一种平台上运行。嵌入式系统的资源有限 2.3 交叉工具链交叉工具链包含GCC、binutils、glibc等，在嵌入式环境中，通常使用uclibc等小型的C语言库。 arm-linux-gnueabi：编译ARM32架构的u-boot、Linux内核以及Linux应用程序 aarch-linux-gnueabi：用于基于ARM64架构的Linux系统 arm-linux-gnueabihf：hf指支持硬件浮点（Hard Float）的ARM处理器 2.4 GCC 编译GCC 编译命令的一般格式：gcc [选项] 源文件 [选项] 目标文件","categories":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"《奔跑吧Linux内核入门篇》","slug":"《奔跑吧Linux内核入门篇》","permalink":"/tags/《奔跑吧Linux内核入门篇》/"}],"keywords":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}]},{"title":"Linux系统入门","slug":"java01.Java编程入门","date":"2019-08-28T14:30:00.000Z","updated":"2019-10-03T15:42:34.000Z","comments":true,"path":"2019/08/28/java01.Java编程入门/","link":"","permalink":"/2019/08/28/java01.Java编程入门/","excerpt":"","text":"Java编程入门1. About Java1.1 Java 技术的发展Java由SUN（Stanford University Network）于1995年发布。 Java SE：Java标准开发版（J2SE），提供底层支持，实现桌面程序的开发。 Java ME：Java嵌入式开发版（J2ME） Java EE：Java企业开发版（J2EE），用于企业/互联网平台的搭建。 1.2 Java 特点 通用 面向对象 内存回收机制 使用引用代替指针 支持多线程编程（正确的多线程使用时提升处理性能的核心） 高效的网络处理 良好的可移植性（JVM） 2. 要点2.1 类定义[public] class 类名称{} ，public类名称必须要与文件名称一致，且一个.java文件中只能有一个public class的定义。类名称命名示例：HelloWorld首字母大写。 2.2 主方法定义主方法时程序执行的入口，在类中定义。 public class HelloWorld{ public static void main (String args[]){ System.out.println(&quot;Hello World!&quot;); } } 2.3 注释 //单行注释； /*.....*/多行注释； /**....*/文档注释。 2.4 标识符由字母、数字、_、$组成。不能使用数字开头，不能使用Java保留字。 2.5 数据类型2.5.1 基本数据类型 数值型：整型（byte、short、int、long，默认值0）；浮点型（float、double，默认值0.0）。 布尔型：boolean，默认值false。 字符型：char，默认值’\\u0000’。 2.5.2 引用数据类型数组、类、接口，默认值null。 2.5.3 基本数据类型使用注意事项 数字首选int、double。 要进行数据传输或文字编码转换使用byte。 处理中文用char最方便。 描述内存或文件大小、描述表的主键列（等自动增长的数据）可用long。 2.6 整型数据注意 保存范围：byte、short、int、long 整数常量默认是int，加L或l强制类型转换为long（一般不用l，易于1混淆），如long a = 200L; byte b = 20; Java对byte做了特殊处理，如果没有超过byte范围的常量可自动由int变为byte；超过要进行强制类型转换（会溢出）。 2.7 浮点型数据注意Java中任何一个小数常量为double，因此：float a = (float)10.2;或float a = 10.2F;。自动转型：从小类型到大类型，但是从float到double会有问题。 2.8 典型字符范围‘A’65 ~ ‘Z 90; ‘a’97 ~ ‘z’122; ‘0’48 ~ ‘9’57。 2.9 运算符 2.9.1 简化的运算符+=, -=, *= , /=, %= 2.9.2 自增/减 ++x;--y; 先自增/减，再取x的值作为表达式的值 x++;y--; 先取x的值，再自增/减 2.9.3 三目赋值运算符关系运算 ？满足时的取值 : 不满足时的取值int max = x&gt;y ? x : y; 2.9.4 位运算 &amp; 与 | 或 ^ 异或（相同为0，不同为1） &lt;&lt;`&gt;&gt;` 左移/右移 2.10 &amp;（与）和&amp;&amp;（短路与），|和||的区别1）&amp;和｜两个运算可以进行位运算和逻辑运算 在进行逻辑运算时，所有的判断条件都要执行 在进行位运算时，只是针对当前数据进行处理 2）&amp;&amp;和||用于逻辑运算 若&amp;&amp;左边为flase，则不再判断右边，直接等于false 若||左边为true，则不再判断右边，直接等于true 2.11 逻辑控制switch 判断内容只能是int、char、枚举（1.5）、String（1.7）；明确循环次数用for；只知结束条件用while。 2.12 方法的名称同变量名称，第一个单词首字母小写，后首字母大写 2.13 方法重载与返回值类型无关。（一个开发原则，建议返回类型相同）方法名相同，参数类型和个数不同成为方法重载。","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Java","slug":"Java","permalink":"/tags/Java/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"Linux系统入门","slug":"1.Linux系统入门","date":"2019-08-28T14:30:00.000Z","updated":"2019-08-28T15:27:40.000Z","comments":true,"path":"2019/08/28/1.Linux系统入门/","link":"","permalink":"/2019/08/28/1.Linux系统入门/","excerpt":"","text":"Linux系统入门1. Linux 诞生于1991年10月5日2. Linux发行版2.1 Red Hat Linux2.1.1 Fedora Core Fedora Core 发行版是Red Hat 公司的新技术测试平台，由Fedora Project 社区开发； 新技术首先应用到Fedora Core，等测试稳定了在加入Red Hat 的RHEL 版本中； 面向桌面，提供最新的软件包。 2.1.2 RHEL 面向服务器； 注重性能、稳定性和服务端软件支持。 2.1.3 CentOS Linux 全称为 Community Enterprise Operating System 根据RHEL 的源代码重新编译而成； 商业产品，免费使用； 不包含封闭源代码的软件。 2.2 Debian Linux Debian 一般指Debian GNU/Linux； 特有apt-get/dpkg 软件包管理工具； Ubuntu 和Deepin 基于Debian。 3. Linux内核3.1 宏内核所有内核代码都编译成一个二进制文件，所有的内核代码都运行在一个大的内核地址空间，内核代码可以直接访问和调用，效率高，性能好。 3.2 微内核把操作系统分成多个独立的功能模块，每个功能模块之间的访问需要通过消息完成，效率不高，但稳定性和实时性好。 3.3 Linux 宏内核 模块化设计 抢占式内核 动态加载内核模块 4. GCC 版本切换使用 update-alternetives命令对GCC工具的多个版本进行切换 5. 使用busybox手工编译一个最小文件系统","categories":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"/tags/笔记/"},{"name":"Linux","slug":"Linux","permalink":"/tags/Linux/"},{"name":"《奔跑吧Linux内核入门篇》","slug":"《奔跑吧Linux内核入门篇》","permalink":"/tags/《奔跑吧Linux内核入门篇》/"}],"keywords":[{"name":"LinuxKernel","slug":"LinuxKernel","permalink":"/categories/LinuxKernel/"}]},{"title":"Markdown 高级技巧","slug":"10_Markdown高级技巧","date":"2019-07-30T14:16:01.000Z","updated":"2019-08-21T00:43:26.000Z","comments":true,"path":"2019/07/30/10_Markdown高级技巧/","link":"","permalink":"/2019/07/30/10_Markdown高级技巧/","excerpt":"","text":"Markdown 高级技巧1、支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如： 使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 输出结果为：使用 Ctrl+Alt+Del 重启电脑 2、转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符： **文本加粗** \\*\\* 正常显示星号 \\*\\* 输出结果为：文本加粗** 正常显示星号 **Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线 ` 反引号 * 星号 _ 下划线 {} 花括号 [] 方括号 () 小括号 # 井字号 + 加号 - 减号 . 英文句点 ! 感叹号 3、公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如： $$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} &amp; \\mathbf{j} &amp; \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} &amp; \\frac{\\partial Y}{\\partial u} &amp; 0 \\\\ \\frac{\\partial X}{\\partial v} &amp; \\frac{\\partial Y}{\\partial v} &amp; 0 \\\\ \\end{vmatrix} $$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}} $$ 输出结果为： 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 表格","slug":"09_Markdown表格","date":"2019-07-26T16:00:00.000Z","updated":"2019-08-21T00:43:23.000Z","comments":true,"path":"2019/07/27/09_Markdown表格/","link":"","permalink":"/2019/07/27/09_Markdown表格/","excerpt":"","text":"Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 以上代码显示结果如下：| 表头 | 表头 || —- | —- || 单元格 | 单元格 || 单元格 | 单元格 | 对齐方式 -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 实例如下： | 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 以上代码显示结果如下：| 左对齐 | 右对齐 | 居中对齐 || :—–| —-: | :—-: || 单元格 | 单元格 | 单元格 || 单元格2 | 单元格2 | 单元格2 | 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 图片","slug":"08_Markdown图片","date":"2019-07-25T16:00:00.000Z","updated":"2019-08-21T00:43:20.000Z","comments":true,"path":"2019/07/26/08_Markdown图片/","link":"","permalink":"/2019/07/26/08_Markdown图片/","excerpt":"","text":"Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) ![alt 属性文本](图片地址 &quot;可选标题&quot;) 开头一个感叹号 ! 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。 使用实例： ![RUNOOB 图标](https://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png) ![RUNOOB 图标](https://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png &quot;RUNOOB&quot;) 显示结果如下： 当然，你也可以像网址那样对图片网址使用变量: 这个链接用 1 作为网址变量 [RUNOOB][1]. 然后在文档的结尾位变量赋值（网址） [1]: https://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。 &lt;img src=&quot;https://www.runoob.com/wp-content/themes/runoob/assets/img/runoob-logo.png&quot; width=&quot;10%&quot;&gt; 显示结果如下： 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 链接","slug":"07_Markdown链接","date":"2019-07-23T16:00:00.000Z","updated":"2019-08-21T00:43:17.000Z","comments":true,"path":"2019/07/24/07_Markdown链接/","link":"","permalink":"/2019/07/24/07_Markdown链接/","excerpt":"","text":"Markdown 链接1、基本用法链接使用方法如下： [链接名称](链接地址) 或者 &lt;链接地址&gt; 例如： 这是一个链接 [菜鸟教程](https://www.runoob.com) 显示结果如下：这是一个链接 菜鸟教程直接使用链接地址： &lt;https://www.runoob.com&gt; 显示结果如下：https://www.runoob.com 2、高级链接链接也可以用变量来代替，文档末尾附带变量地址： 这个链接用 1 作为网址变量 [Google][1] 这个链接用 runoob 作为网址变量 [Runoob][runoob] 然后在文档的结尾为变量赋值（网址） [1]: http://www.google.com/ [runoob]: http://www.runoob.com/ 显示结果如下：链接也可以用变量来代替，文档末尾附带变量地址：这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址） 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 代码","slug":"06_Markdown代码","date":"2019-07-23T16:00:00.000Z","updated":"2019-08-21T00:43:14.000Z","comments":true,"path":"2019/07/24/06_Markdown代码/","link":"","permalink":"/2019/07/24/06_Markdown代码/","excerpt":"","text":"Markdown 代码1、基本用法如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如： `printf()` 函数 显示结果如下：printf() 函数 2、代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。实例如下：显示结果如下：你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：显示结果如下： $(document).ready(function () { alert(&#39;RUNOOB&#39;); }); 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 区块","slug":"05_Markdown区块","date":"2019-07-22T16:00:00.000Z","updated":"2019-08-21T00:43:11.000Z","comments":true,"path":"2019/07/23/05_Markdown区块/","link":"","permalink":"/2019/07/23/05_Markdown区块/","excerpt":"","text":"Markdown 区块1、区块基本用法Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号： &gt; 区块引用 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想 显示结果如下： 区块引用菜鸟教程学的不仅是技术更是梦想 另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推退： &gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套 显示结果如下： 最外层 第一层嵌套 第二层嵌套 2、区块中使用列表区块中使用列表实例如下： &gt; 区块中使用列表 &gt; 1. 第一项 &gt; 2. 第二项 &gt; + 第一项 &gt; + 第二项 &gt; + 第三项 显示结果如下： 区块中使用列表 第一项 第二项 第一项 第二项 第三项 3、列表中使用区块如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。区块中使用列表实例如下： * 第一项 &gt; 菜鸟教程 &gt; 学的不仅是技术更是梦想 * 第二项 显示结果如下： 第一项 菜鸟教程学的不仅是技术更是梦想 第二项 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 列表","slug":"04_Markdown列表","date":"2019-07-21T16:00:00.000Z","updated":"2019-08-21T00:43:07.000Z","comments":true,"path":"2019/07/22/04_Markdown列表/","link":"","permalink":"/2019/07/22/04_Markdown列表/","excerpt":"","text":"Markdown 列表1、列表基本用法Markdown 支持有序列表和无序列表。无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记： * 第一项 * 第二项 * 第三项 + 第一项 + 第二项 + 第三项 - 第一项 - 第二项 - 第三项 显示结果如下： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 有序列表使用数字并加上 . 号来表示，如： 1. 第一项 2. 第二项 3. 第三项 显示结果如下： 第一项 第二项 第三项 2、列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 1. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素 2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第一个元素 显示结果如下： 第一项： 第一项嵌套的第一个元素 第一项嵌套的第二个元素 第二项： 第二项嵌套的第一个元素 第二项嵌套的第一个元素 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 段落","slug":"03_Markdown段落格式","date":"2019-07-20T16:00:00.000Z","updated":"2019-08-21T00:43:04.000Z","comments":true,"path":"2019/07/21/03_Markdown段落格式/","link":"","permalink":"/2019/07/21/03_Markdown段落格式/","excerpt":"","text":"Markdown 段落1、段落Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。 当然也可以在段落后面使用一个空行来表示重新开始一个段落。 2、字体Markdown 可以使用以下几种字体： *斜体文本* _斜体文本_ **粗体文本** __粗体文本__ ***粗斜体文本*** ___粗斜体文本___ 显示效果如下所示： 3、分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： *** * * * ***** - - - ---------- 显示效果如下所示： 4、删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下： RUNOOB.COM GOOGLE.COM ~~BAIDU.COM~~ 显示效果如下所示： 5、下划线下划线可以通过 HTML 的 &lt;u&gt; 标签来实现： &lt;u&gt;带下划线文本&lt;/u&gt; 显示效果如下所示：带下划线文本 6、脚注脚注是对文本的补充说明。Markdown 脚注的格式如下: [^要注明的文本] 以下实例演示了脚注的用法 创建脚注格式类似这样 [^RUNOOB]。 [^RUNOOB]: 菜鸟教程 -- 学的不仅是技术，更是梦想！！！ 演示效果如下： 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 标题","slug":"02_Markdown标题","date":"2019-07-20T16:00:00.000Z","updated":"2019-08-21T00:45:43.000Z","comments":true,"path":"2019/07/21/02_Markdown标题/","link":"","permalink":"/2019/07/21/02_Markdown标题/","excerpt":"","text":"Markdown 标题Markdown 标题有两种格式。 1、使用 = 和 - 标记一级和二级标题= 和 - 标记语法格式如下： 我展示的是一级标题 ================= 我展示的是二级标题 ----------------- 显示效果如下图： 2、使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 显示效果如下图 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]},{"title":"Markdown 教程","slug":"01_Markdown教程","date":"2019-07-19T16:00:00.000Z","updated":"2019-08-21T00:41:59.000Z","comments":true,"path":"2019/07/20/01_Markdown教程/","link":"","permalink":"/2019/07/20/01_Markdown教程/","excerpt":"","text":"Markdown 教程 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 1、Markdown应用Markdown 能被使用来撰写电子书，如：Gitbook。当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 2、编辑器本教程将使用 Typora 编辑器来讲解 Markdown 的语法，Typora 支持 MacOS 、Windows、Linux 平台，且包含多种主题，编辑后直接渲染出效果。支持导出HTML、PDF、Word、图片等多种类型文件。Typora 官网：https://typora.io/你也可以使用我们的在线编辑器来测试：https://c.runoob.com/front-end/712。 3、测试实例Mardown 编写 Hello World! 语法： # Hello World! 将该代码格式粘贴到 Typora 效果如下： 【转载自 菜鸟教程】","categories":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}],"tags":[{"name":"教程","slug":"教程","permalink":"/tags/教程/"}],"keywords":[{"name":"Markdown","slug":"Markdown","permalink":"/categories/Markdown/"}]}]}